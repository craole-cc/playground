src/provider/custom.rs:

contents:
use super::prelude::*;

pub struct Provider {
  pub base_url: String
}

impl Provider {
  pub fn new(base_url: String) -> Self {
    Self { base_url }
  }

  pub fn parse_custom_format(&self, url: &str) -> Result<Breed> {
    let breed_str = url
      .split('/')
      .nth_back(0)
      .ok_or_else(|| Error::Url(format!("No breed in URL: {url}")))?
      .split('.')
      .next()
      .ok_or_else(|| Error::Url(format!("No breed identifier: {url}")))?;

    let mut parts = breed_str.splitn(2, '-');
    match (parts.next(), parts.next()) {
      (Some(a), Some(b)) => Ok(Breed::new(
        b,
        Some(a),
        format!("{}/breed/{}/{}", self.base_url, b, a),
        Breed::format_name(b, Some(a))
      )),
      (Some(a), None) => Ok(Breed::new(
        a,
        None::<String>,
        format!("{}/breed/{}", self.base_url, a),
        Breed::format_name(a, None)
      )),
      _ => Err(Error::BreedFormat(format!("Invalid format: {breed_str}")))
    }
  }

  // Provider-specific photo parsing
  async fn parse_photo_response(
    &self,
    source: DataSource<'_>
  ) -> Result<String> {
    let json = fetch_json(source).await?;

    // Try common photo URL field names
    json
      .get("url")
      .or_else(|| json.get("message"))
      .or_else(|| json.get("image"))
      .or_else(|| json.get("photo"))
      .and_then(|v| v.as_str())
      .map(|s| s.to_string())
      .ok_or_else(|| Error::EmptyResponse)
  }

  // Provider-specific breed parsing
  async fn parse_breed_response(
    &self,
    source: DataSource<'_>
  ) -> Result<Breed> {
    let json = fetch_json(source).await?;

    let main_breed = json
      .get("breed")
      .and_then(|v| v.as_str())
      .ok_or_else(|| Error::EmptyResponse)?;

    let sub_breed = json.get("sub_breed").and_then(|v| v.as_str());

    Ok(Breed::new(
      main_breed,
      sub_breed,
      format!("{}/breed/{}", self.base_url, main_breed),
      Breed::format_name(main_breed, sub_breed)
    ))
  }
}

#[async_trait]
impl Content for Provider {
  async fn photo(&self, source: DataSource<'_>) -> Result<String> {
    // Try parsing as JSON first
    match self.parse_photo_response(source.clone()).await {
      Ok(photo_url) => Ok(photo_url),
      Err(_) => {
        // Fallback: if it's a URL, just return it directly
        match source {
          DataSource::Url(url) => Ok(url.to_string()),
          _ => Err(Error::Provider(
            "Cannot extract photo from non-URL source".to_string()
          ))
        }
      }
    }
  }

  async fn breed(&self, source: DataSource<'_>) -> Result<Breed> {
    // Try parsing as structured breed data first
    match self.parse_breed_response(source.clone()).await {
      Ok(breed) => Ok(breed),
      Err(_) => {
        // Fallback: try extracting from photo URL
        match source {
          DataSource::Url(url) => {
            let photo_url = self.photo(DataSource::Url(url)).await?;
            self.parse_custom_format(&photo_url)
          }
          _ => Err(Error::Provider(
            "Cannot parse breed from this source".to_string()
          ))
        }
      }
    }
  }
}

============================

src/provider/default.rs:

contents:
use super::{prelude::*, *};
use std::{
  collections::hash_map::DefaultHasher,
  hash::{Hash, Hasher},
  path::{Path, PathBuf},
  time::{SystemTime, UNIX_EPOCH}
};

#[derive(Debug, Default, Clone)]
pub enum Provider {
  #[default]
  DogCeo,
  Random,
  Custom(String)
}

impl Provider {
  fn known_providers() -> Vec<Provider> {
    vec![Provider::DogCeo]
  }

  fn select_random() -> Provider {
    let known = Self::known_providers();
    if known.is_empty() {
      return Provider::DogCeo;
    }

    let now = SystemTime::now()
      .duration_since(UNIX_EPOCH)
      .unwrap_or_default()
      .as_nanos();

    let mut hasher = DefaultHasher::new();
    now.hash(&mut hasher);
    let hash = hasher.finish();

    let index = (hash as usize) % known.len();
    known[index].clone()
  }

  pub async fn photo(&self, url: Option<&str>) -> Result<String> {
    match self {
      Provider::DogCeo => {
        let source = match url {
          Some(url_str) => DataSource::Url(url_str),
          None => DataSource::Url("https://dog.ceo/api/breeds/image/random")
        };
        dog_ceo::Provider.photo(source).await
      }
      Provider::Random => {
        let random_provider = Self::select_random();
        match random_provider {
          Provider::DogCeo => {
            let source = match url {
              Some(url_str) => DataSource::Url(url_str),
              None => DataSource::Url("https://dog.ceo/api/breeds/image/random")
            };
            dog_ceo::Provider.photo(source).await
          }
          Provider::Custom(base_url) => {
            let source = match url {
              Some(url_str) => DataSource::Url(url_str),
              None => DataSource::Url(&base_url)
            };
            custom::Provider::new(base_url.clone()).photo(source).await //TODO Is this expensive?
          }
          Provider::Random => {
            let source = match url {
              Some(url_str) => DataSource::Url(url_str),
              None => DataSource::Url("https://dog.ceo/api/breeds/image/random")
            };
            dog_ceo::Provider.photo(source).await
          }
        }
      }
      Provider::Custom(base_url) => {
        let source = match url {
          Some(url_str) => DataSource::Url(url_str),
          None => DataSource::Url(base_url)
        };
        custom::Provider::new(base_url.clone()).photo(source).await
      }
    }
  }

  pub async fn breed<P: AsRef<Path> + Send + Sync>(
    &self,
    photo_url: Option<&str>,
    breeds_url: Option<&str>,
    breeds_path: Option<P>
  ) -> Result<Breed> {
    match self {
      Provider::DogCeo => {
        let source = match photo_url {
          Some(url_str) => DataSource::Url(url_str),
          None => DataSource::Url("https://dog.ceo/api/breeds/image/random")
        };
        dog_ceo::Provider.breed(source).await
      }
      Provider::Random => {
        if let Some(url) = photo_url {
          if url.contains("dog.ceo") {
            let source = DataSource::Url(url);
            return dog_ceo::Provider.breed(source).await;
          }
        }
        Ok(Breed::new(
          String::from("Unknown"),
          None::<String>,
          String::from(""),
          String::from("Unknown Breed")
        ))
      }
      Provider::Custom(base_url) => {
        let source = match photo_url {
          Some(url_str) => DataSource::Url(url_str),
          None => DataSource::Url(base_url)
        };
        custom::Provider::new(base_url.clone()).breed(source).await
      }
    }
  }

  pub fn dog_ceo() -> Self {
    Provider::DogCeo
  }

  pub fn random() -> Self {
    Provider::Random
  }

  pub fn custom<S: Into<String>>(base_url: S) -> Self {
    Provider::Custom(base_url.into())
  }
}

#[cfg(test)]
mod tests {
  use super::*;
  use mockito::mock;
  use tempfile::tempdir;

  #[tokio::test]
  async fn test_dog_ceo_photo() {
    let _m = mock("GET", "/api/breeds/image/random")
      .with_status(200)
      .with_body(
        r#"{"message":"https://dog.ceo/photo.jpg","status":"success"}"#
      )
      .create();

    let provider = Provider::dog_ceo();
    let result = provider.photo(Some(&mockito::server_url())).await;

    assert!(result.is_ok());
    assert_eq!(result.unwrap(), "https://dog.ceo/photo.jpg");
  }

  #[tokio::test]
  async fn test_random_provider_photo() {
    let provider = Provider::random();
    let result = provider.photo(None).await;
    assert!(result.is_ok());
  }

  #[tokio::test]
  async fn test_custom_provider_photo() {
    let _m = mock("GET", "/")
      .with_status(200)
      .with_body(r#"{"url":"https://custom.com/dog.jpg"}"#)
      .create();

    let provider = Provider::custom(mockito::server_url());
    let result = provider.photo(None).await;

    assert!(result.is_ok());
    assert_eq!(result.unwrap(), "https://custom.com/dog.jpg");
  }

  #[tokio::test]
  async fn test_dog_ceo_breed() {
    let temp_dir = tempdir().unwrap();
    let breeds_path = temp_dir.path().join("breeds.json");

    let _m1 = mock("GET", "/api/breeds/image/random")
            .with_body(r#"{"message":"https://images.dog.ceo/breeds/hound-afghan/123.jpg","status":"success"}"#)
            .create();

    let _m2 = mock("GET", "/api/breeds/list/all")
      .with_body(r#"{"message":{"hound":["afghan"]},"status":"success"}"#)
      .create();

    let provider = Provider::dog_ceo();
    let result = provider
      .breed(
        Some(&mockito::server_url()),
        Some(&mockito::server_url()),
        Some(breeds_path)
      )
      .await;

    assert!(result.is_ok());
    let breed = result.unwrap();
    assert_eq!(breed.display_name, "Afghan Hound");
  }
}

============================

src/provider/dog_ceo.rs:

contents:
use crate::provider::prelude::*;
use serde::{Deserialize, Serialize};
use std::{
  fs,
  path::{Path, PathBuf}
};

const DOG_CEO_RANDOM_URL: &str = "https://dog.ceo/api/breeds/image/random";
const DOG_CEO_BREEDS_URL: &str = "https://dog.ceo/api/breeds/list/all";
const DOG_CEO_BREEDS_JSON: &str = "assets/data/dog_ceo_breeds.json";

#[derive(Deserialize, Debug)]
pub struct PhotoApiResponse {
  pub message: String,
  pub status: String
}

#[derive(Deserialize, Serialize, Debug)]
pub struct BreedsApiResponse {
  pub message: std::collections::HashMap<String, Vec<String>>,
  pub status: String
}

pub struct Provider;

impl Provider {
  pub fn extract_breed_from_url(url: &str) -> Result<(String, Option<String>)> {
    debug!("Extracting breed from URL: {}", url);
    let parts: Vec<&str> = url
      .split("/breeds/")
      .nth(1)
      .ok_or_else(|| Error::Url(format!("URL missing breed segment: {url}")))?
      .split('/')
      .next()
      .ok_or_else(|| {
        Error::Url(format!("URL missing breed identifier: {url}"))
      })?
      .split('-')
      .collect();

    match parts.as_slice() {
      [main] => {
        debug!("Found main breed: {}", main);
        Ok((main.to_string(), None))
      }
      [main, sub] => {
        debug!("Found sub-breed: {} - {}", sub, main);
        Ok((main.to_string(), Some(sub.to_string())))
      }
      _ => Err(Error::BreedFormat(format!(
        "Expected 'main' or 'main-sub' format, got: {url}"
      )))
    }
  }

  pub async fn get_breeds<P: AsRef<Path>>(
    breeds_path: Option<P>,
    breeds_url: Option<&str>
  ) -> Result<BreedsApiResponse> {
    let path = breeds_path.map_or_else(
      || PathBuf::from(DOG_CEO_BREEDS_JSON),
      |p| p.as_ref().to_path_buf()
    );

    let url = breeds_url.unwrap_or(DOG_CEO_BREEDS_URL);
    debug!("Fetching breeds from: {}", url);

    // Check if we should use cached data
    if fs::metadata(&path).is_ok() {
      debug!("Using cached breeds file");
      let content = fs::read_to_string(&path)?;
      return serde_json::from_str(&content).map_err(Into::into);
    }

    debug!("Breeds file not found, downloading...");
    let response = reqwest::get(url).await?;
    let breeds_data: BreedsApiResponse = response.json().await?;

    // Cache the response
    if let Some(parent) = path.parent() {
      fs::create_dir_all(parent)?;
    }
    let content =
      serde_json::to_string_pretty(&breeds_data).map_err(Error::Json)?;
    fs::write(&path, content)?;

    Ok(breeds_data)
  }

  pub fn verify_breed(
    main: &str,
    sub: &Option<String>,
    breeds: &BreedsApiResponse
  ) -> Result<()> {
    debug!("Verifying breed: {} {:?}", main, sub);
    let valid = match sub {
      Some(s) => breeds
        .message
        .get(main)
        .map(|subs| subs.contains(s))
        .unwrap_or(false),
      None => breeds.message.contains_key(main)
    };

    if !valid {
      let breed_name = sub
        .as_ref()
        .map_or(main.to_string(), |s| format!("{s} {main}"));
      warn!("Unrecognized breed: {}", breed_name);
      Err(Error::UnrecognizedBreed(breed_name))
    } else {
      debug!("Breed verified");
      Ok(())
    }
  }

  pub fn build_reference_url(
    breed: &str,
    sub_breed: &Option<String>
  ) -> String {
    match sub_breed {
      Some(sub) => format!("https://dog.ceo/api/breed/{breed}/{sub}"),
      None => format!("https://dog.ceo/api/breed/{breed}")
    }
  }

  async fn fetch_photo_from_url(&self, url: &str) -> Result<String> {
    debug!("Fetching photo from: {}", url);
    let response = reqwest::get(url).await?;
    let photo_response: PhotoApiResponse = response.json().await?;
    Ok(photo_response.message)
  }

  async fn breed_from_photo_url(&self, photo_url: &str) -> Result<Breed> {
    let (main, sub) = Self::extract_breed_from_url(photo_url)?;

    debug!("Getting breeds data");
    let breeds_data = Self::get_breeds(None::<PathBuf>, None).await?;

    let url_reference = Self::build_reference_url(&main, &sub);
    debug!("Reference URL: {url_reference}");

    let display_name = match Self::verify_breed(&main, &sub, &breeds_data) {
      Ok(_) => {
        debug!("Breed verified");
        Breed::format_name(&main, sub.as_deref())
      }
      Err(_) => {
        warn!("Breed not verified");
        format!("{} (unverified)", Breed::format_name(&main, sub.as_deref()))
      }
    };

    info!("Formatted breed: {}", display_name);
    Ok(Breed::new(main, sub, url_reference, display_name))
  }
}

#[async_trait]
impl Content for Provider {
  async fn photo(&self, source: DataSource<'_>) -> Result<String> {
    match source {
      DataSource::Url(url) => {
        // If it's already a direct image URL, return it
        if url.contains("images.dog.ceo") {
          Ok(url.to_string())
        } else {
          // Otherwise, fetch from the API
          self.fetch_photo_from_url(url).await
        }
      }
      DataSource::File(path) => {
        // Read JSON from file and extract photo URL
        let json = fetch_json(source).await?;
        json
          .get("message")
          .and_then(|v| v.as_str())
          .map(|s| s.to_string())
          .ok_or_else(|| Error::EmptyResponse)
      }
      DataSource::Raw(data) => {
        // Parse JSON from raw data
        let json: serde_json::Value = serde_json::from_slice(data)?;
        json
          .get("message")
          .and_then(|v| v.as_str())
          .map(|s| s.to_string())
          .ok_or_else(|| Error::EmptyResponse)
      }
    }
  }

  async fn breed(&self, source: DataSource<'_>) -> Result<Breed> {
    match source {
      DataSource::Url(url) => {
        // If it's a direct image URL, extract breed from it
        if url.contains("images.dog.ceo") {
          self.breed_from_photo_url(url).await
        } else {
          // Otherwise, fetch photo URL first, then extract breed
          let photo_url = self.photo(source).await?;
          self.breed_from_photo_url(&photo_url).await
        }
      }
      DataSource::File(_) | DataSource::Raw(_) => {
        // For file/raw data, get the photo URL first
        let photo_url = self.photo(source).await?;
        self.breed_from_photo_url(&photo_url).await
      }
    }
  }
}

#[cfg(test)]
mod tests {
  use super::*;
  use mockito::{mock, server_url};
  use tempfile::tempdir;

  const TEST_IMAGE_URL: &str =
    "https://images.dog.ceo/breeds/hound-afghan/n02088094_1003.jpg";
  const TEST_BREEDS_DATA: &str =
    r#"{"message":{"hound":["afghan"]},"status":"success"}"#;

  #[tokio::test]
  async fn test_photo_from_api() {
    let _m = mock("GET", "/api/breeds/image/random")
      .with_status(200)
      .with_header("content-type", "application/json")
      .with_body(format!(
        r#"{{"message":"{TEST_IMAGE_URL}","status":"success"}}"#
      ))
      .create();

    let provider = Provider;
    let test_url = format!("{}/api/breeds/image/random", server_url());
    let result = provider.photo(DataSource::Url(&test_url)).await;

    assert!(result.is_ok());
    assert_eq!(result.unwrap(), TEST_IMAGE_URL);
  }

  #[tokio::test]
  async fn test_photo_direct_url() {
    let provider = Provider;
    let result = provider.photo(DataSource::Url(TEST_IMAGE_URL)).await;

    assert!(result.is_ok());
    assert_eq!(result.unwrap(), TEST_IMAGE_URL);
  }

  #[tokio::test]
  async fn test_extract_breed_from_url() {
    let result = Provider::extract_breed_from_url(TEST_IMAGE_URL);
    assert!(result.is_ok());
    let (main, sub) = result.unwrap();
    assert_eq!(main, "hound");
    assert_eq!(sub, Some("afghan".to_string()));
  }

  #[tokio::test]
  async fn test_breed_from_direct_url() {
    let temp_dir = tempdir().unwrap();
    let breeds_path = temp_dir.path().join("breeds.json");

    // Create mock breeds file
    fs::write(&breeds_path, TEST_BREEDS_DATA).unwrap();

    let _m = mock("GET", "/api/breeds/list/all")
      .with_status(200)
      .with_body(TEST_BREEDS_DATA)
      .create();

    let provider = Provider;
    let result = provider.breed(DataSource::Url(TEST_IMAGE_URL)).await;

    assert!(result.is_ok());
    let breed = result.unwrap();
    assert_eq!(breed.main_breed, "hound");
    assert_eq!(breed.sub_breed, Some("afghan".to_string()));
    assert_eq!(breed.display_name, "Afghan Hound");
  }

  #[tokio::test]
  async fn test_breed_from_api() {
    let _photo_mock = mock("GET", "/api/breeds/image/random")
      .with_status(200)
      .with_body(format!(
        r#"{{"message":"{TEST_IMAGE_URL}","status":"success"}}"#
      ))
      .create();

    let _breeds_mock = mock("GET", "/api/breeds/list/all")
      .with_status(200)
      .with_body(TEST_BREEDS_DATA)
      .create();

    let provider = Provider;
    let test_url = format!("{}/api/breeds/image/random", server_url());
    let result = provider.breed(DataSource::Url(&test_url)).await;

    assert!(result.is_ok());
    let breed = result.unwrap();
    assert_eq!(breed.main_breed, "hound");
    assert_eq!(breed.sub_breed, Some("afghan".to_string()));
    assert_eq!(breed.display_name, "Afghan Hound");
  }
}

============================

src/provider/mod.rs:

contents:
//|-> Modules
mod custom;
mod default;
mod dog_ceo;
mod prelude;

//|-> Internal Exports
pub use prelude::*;

//|-> External Exports
// pub use default::Provider;
// pub use default::Config;
// pub use provider::Provider;

============================

src/provider/prelude.rs:

contents:
pub use crate::prelude::*;
use crate::utils::format::capitalize_first_letter;
pub use async_trait::async_trait;
pub use std::path::Path;
use tokio::fs;

// Generic source enum for any data type
#[derive(Debug, Clone)]
pub enum DataSource<'a> {
  Url(&'a str),
  File(&'a Path),
  Raw(&'a [u8])
}

// Simplified Content trait - providers handle their own parsing
#[async_trait]
pub trait Content {
  async fn photo(&self, source: DataSource<'_>) -> Result<String>;
  async fn breed(&self, source: DataSource<'_>) -> Result<Breed>;
}

#[derive(Debug)]
pub struct Breed {
  pub main_breed: String,
  pub sub_breed: Option<String>,
  pub url_reference: String,
  pub display_name: String
}

impl Breed {
  pub fn new(
    main_breed: impl Into<String>,
    sub_breed: Option<impl Into<String>>,
    url_reference: impl Into<String>,
    display_name: impl Into<String>
  ) -> Self {
    Self {
      main_breed: main_breed.into(),
      sub_breed: sub_breed.map(Into::into),
      url_reference: url_reference.into(),
      display_name: display_name.into()
    }
  }

  pub fn format_name(main: &str, sub: Option<&str>) -> String {
    match sub {
      Some(s) => format!(
        "{} {}",
        capitalize_first_letter(s),
        capitalize_first_letter(main)
      ),
      None => capitalize_first_letter(main)
    }
  }
}

// Helper functions for common parsing patterns
pub async fn fetch_data(source: DataSource<'_>) -> Result<Vec<u8>> {
  match source {
    DataSource::Url(url) => {
      let response = reqwest::get(url).await?;
      Ok(response.bytes().await?.to_vec())
    }
    DataSource::File(path) => Ok(fs::read(path).await?),
    DataSource::Raw(data) => Ok(data.to_vec())
  }
}

pub async fn fetch_json(source: DataSource<'_>) -> Result<serde_json::Value> {
  let data = fetch_data(source).await?;
  Ok(serde_json::from_slice(&data)?)
}

pub async fn fetch_text(source: DataSource<'_>) -> Result<String> {
  let data = fetch_data(source).await?;
  Ok(String::from_utf8_lossy(&data).to_string())
}
